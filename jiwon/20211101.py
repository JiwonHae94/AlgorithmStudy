# -------------------------------------
# category : Binary Search
# Q : n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.
#     처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.
#     모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.
#     입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.
def solution(n, times):
    answer = 0

    # left -> 가장 효율절으로 업무를 진행했을 때 걸릴 시간
    # right -> 가장 비효율적으로 업무를 진행했을 때 걸릴 시간
    left, right = 0, max(times) * n

    while left <= right:
        mid = (left + right) // 2
        ppl = 0

        for time in times:
            # 주어진 시간 mid 에서, 한 심사원이 심사할 수 있는 사람의 수
            ppl += mid // time

        if ppl >= n:
            answer = mid
            right = mid - 1
        else:
            left = mid + 1

    return answer


# -------------------------------------
# category : DP
# Q : 효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는
#     (1칸, 1칸, 1칸, 1칸)
#     (1칸, 2칸, 1칸)
#     (1칸, 1칸, 2칸)
#     (2칸, 1칸, 1칸)
#     (2칸, 2칸)
#     의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.
def solution(n):
    dp = [0] * (n + 1)
    dp[1] = 1
    if n == 1:
        return 1

    dp[2] = 2

    for i in range(3, n + 1):
        dp[i] = (dp[i - 2] + dp[i - 1]) % 1234567

    return dp[n]